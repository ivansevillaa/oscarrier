---
title: "Como Funcionan los Tests en JavaScript"
date: "2021-09-15"
summary: "Es dif√≠cil convertirse en una experto de algo si no sab√©s c√≥mo funciona realmente. Entonces, en este art√≠culo, voy a mostrarte c√≥mo funcionan las assertions libraries y los testing frameworks mientras construimos uno peque√±o."
cover: "/images/posts/test-fundamentals/cover.jpg"
blurHash: "LNJ+x~H@^+tQ~pInE2-qD$IoE2xZ"
slug: "test-fundamentals"
---

En este art√≠culo vamos a cubrir los fundamentos del testing, no vamos a aprender un framework como jest o mocha, sino que vamos a ir m√°s profundo y vamos a crear nuestra propia versi√≥n de un **test framework** y una **assertion library** para realmente entender los fundamentos del mundo del testing. Tambi√©n, voy a explicarte la diferencia entre los test frameworks y las assertion libraries. Por lo tanto no te preocupes sobre estos t√©rminos si todav√≠a no los conoc√©s, porque al final de este art√≠culo vas a entender estos conceptos y m√°s.

Entonces, empecemos con lo m√°s b√°sico de como funcionan el testing. En simples palabras, un test es un <Highlighted text="if statement" /> que arroja un error si algo ocurre de una forma diferente a lo esperado.

Por supuesto existen funciones complejas que los resultados dependen de otra cosa, pero es realmente f√°cil testear funciones que siempre retornan lo mismo para una misma entrada. Por ejemplo una funci√≥n de suma o multiplicaci√≥n.

Primero, creemos un m√≥dulo que luego vamos a testear:

```js:math.js
/* 
 ac√° tenemos un bug en nuestra funci√≥n multiplicar
 para demostrar como funcionan los tests
*/

module.exports = {
  sum: function (a, b) {
    return a + b;
  },
  multiply: function (a, b) {
    return a + b;
  }
};
```

Entonces como dijimos antes, un test es un simple <Highlighted text="if statement" /> que compara el valor real y el valor esperado. Entonces ya teniendo claro esto, vamos a testear nuestro m√≥dulo.

```js:index.js
const { multiply, sum } = require("./math");

let actual, expected;

actual = sum(5, 4);
expected = 9;
if (actual !== expected) {
  throw new Error(`‚ùå FAIL: Expected ${expected} and received ${actual}`);
}

actual = multiply(2, 6);
expected = 12;
if (actual !== expected) {
  throw new Error(`‚ùå FAIL: Expected ${expected} and received ${actual}`);
}
```

Si corremos este test, en la consola podemos ver algo como esto:

```bash
$ node index.js
/Users/oscarrier/test-example/index.js:14
  throw new Error(`‚ùå FAIL: Expected ${expected} and received ${actual}`);
  ^

Error: ‚ùå FAIL: Expected 12 and received 8
    at Object.<anonymous> (/Users/oscarrier/test-example/index.js:14:9)
    at Module._compile (internal/modules/cjs/loader.js:1085:14)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    at Module.load (internal/modules/cjs/loader.js:950:32)
    at Function.Module._load (internal/modules/cjs/loader.js:790:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)
    at internal/main/run_main_module.js:17:47
```

Tremendo, acabamos de crear dos <Highlighted text="assertions" />. Y capaz te est√°s preguntando, qu√© es una assertion? Bueno, es como una comparaci√≥n que nos permite testear valores. Entonces podemos decir que una assertion es una comparaci√≥n que ser√° verdadera al menos que tengamos un bug en lo que estemos testeando.

Pero estamos repitiendo c√≥digo. Encapsulemos esos if statements en algo llamado <Highlighted text="assertion library" />. Una assertion library no es m√°s que una funci√≥n que recibe el valor real y retorna un objeto con varias assertions (comparaciones) que reciben el valor esperado, arrojando un error si la assertion falla. Esto hace mucho mas f√°cil testear nuestro c√≥digo, porque no tenemos que hacer miles de if statements. Creemos una llamada expect con algunas assertions:

```js:index.js
function expect(actual) {
  return {
    toBe(expected) {
      if (actual !== expected) {
        throw new Error(`‚ùå FAIL: Expected ${expected} and received ${actual}`);
      }
    },
    toBeGreaterThan(expected) {
      if (actual <= expected) {
        throw new Error(`‚ùå FAIL: ${actual} is not greater than ${expected}`);
      }
    }
  };
}
```

Y desp√∫es implementemosla:

```js{3,7}:index.js
actual = sum(5, 4);
expected = 9;
 expect(actual).toBe(expected);

actual = multiply(2, 6);
expected = 12;
 expect(actual).toBe(expected);
```

Si corremos el test, nada cambia:

```bash
$ node index.js
/Users/oscarrier/test-example/index.js:14
  throw new Error(`‚ùå FAIL: Expected ${expected} and received ${actual}`);
  ^

Error: ‚ùå FAIL: Expected 12 and received 8
    at Object.<anonymous> (/Users/oscarrier/test-example/index.js:14:9)
    at Module._compile (internal/modules/cjs/loader.js:1085:14)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    at Module.load (internal/modules/cjs/loader.js:950:32)
    at Function.Module._load (internal/modules/cjs/loader.js:790:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)
    at internal/main/run_main_module.js:17:47
```

Ahora es el turno de crear un <Highlighted text="testing framework" />, estos son usados para organizar y ejecutar nuestros tests. Entonces creemos uno:

```js:index.js
function test(title, callback) {
  try {
    callback();
    console.log(`‚úÖ PASS: ${title}`);
  } catch (error) {
    console.error(`‚ùå FAIL: ${title}`);
    console.error(error);
  }
}
```

No es m√°s que una funci√≥n que recibe un t√≠tulo y un callback que ser√° nuestro test. Necesitamos un bloque try-catch porque el test podr√≠a fallar si nuestra assertion library arroja un error y queremos catchear ese error para poder mostrarlo en la consola y continuar corriendo el resto de los tests. Pero si la assertion no falla vamos a ver en la consola que el test pas√≥. Implementemoslo:

```js{1,5,7,11}:index.js
 test("should add", function () {
  const actual = sum(5, 4);
  const expected = 9;
  expect(actual).toBe(expected);
 });

 test("should multiply", function () {
  const actual = multiply(2, 6);
  const expected = 12;
  expect(actual).toBe(expected);
 });
```

Despu√©s de ejecutarlo:

```bash
$ node index.js
‚úÖ PASS: should add
‚ùå FAIL: should multiply
Error: ‚ùå FAIL: Expected 12 and received 8
    at Object.toBe (/Users/oscarrier/test-example/index.js:29:15)
    at /Users/oscarrier/test-example/index.js:12:18
    at test (/Users/oscarrier/test-example/index.js:17:5)
    at Object.<anonymous> (/Users/oscarrier/test-example/index.js:9:1)
    at Module._compile (internal/modules/cjs/loader.js:1085:14)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    at Module.load (internal/modules/cjs/loader.js:950:32)
    at Function.Module._load (internal/modules/cjs/loader.js:790:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)
    at internal/main/run_main_module.js:17:47
```

Si te est√°s preguntando, que pasa si tenemos c√≥digo as√≠ncrono. Bueno para soportar esto necesitamos agregar un <Highlighted text="await" /> al callback en nuestra funci√≥n <Highlighted text="test" /> y hacer as√≠ncrona esta funci√≥n:

```js{3}:index.js
async function test(title, callback) {
  try {
     await callback();
    console.log(`‚úÖ PASS: ${title}`);
  } catch (error) {
    console.error(`‚ùå FAIL: ${title}`);
    console.error(error.message);
  }
}
```

Y si queremos testear algo as√≠ncrono solo tenemos que pasar como callback una funci√≥n as√≠ncrona, y usar await cuando sea necesario. Por ejemplo:

```js
test("should do something async", async function () {
  const actual = await somethingAsync("hello");
  const expected = blabla;
  expect(actual).toBe(expected);
});
```

Perfecto, creamos nuestro testing framework y tambi√©n una assertion library, felicitaciones ü•≥. Podes chequear lo que construimos en [este sandbox.](https://codesandbox.io/s/determined-dawn-0orti?file=/index.js) Tambi√©n, entendimos como funcionan estas herramientas por debajo y aprendimos los fundamentos del testing.

Por supuesto, existen muchisimos conceptos y cosas que no cubrimos en este art√≠culo, pero acordate que esto solo fue una intro a los fundamentos. *Keep learning*, nos vemos üëã
